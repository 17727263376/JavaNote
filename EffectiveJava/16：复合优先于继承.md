[toc]

<font size = "3">

# 继承的缺陷
- 继承打破了封装性

> 子类依赖于超类的实现，如果超类的代码发生了改变，那么子类就会被破坏。
> 
> 对于继承我们有时无法知道超类某个方法的实现，就去覆盖这个方法，当超类的方法有变化，或者由于我们一点不了解超类的方法，这时的子类是具有很大的错误的

- 超类在后续可以添加新的方法
> 比如：一开始超类仅仅提供了一个种A方法，可以改变某个域，在一段时间以后超类推出了另外一个B方法，它和A方法一样可以修改同一个域，这个时候子类就无法控制超类对域的修改
> 
> 即：由于调用了这个未被子类覆盖的新方法，而将“非法的”元素添加到子类的实例中

- 仅仅添加一个新的方法也不安全
> 如果超类在后续的发行版本中获得了一个新的方法，而这个方法与子类提供的方法签名相同但是返回值不同，那么子类就会编译不通过。如果连返回值都相同，那么又回到了上面的两个问题。
# 解决方法
**使用复合，而不用继承**

在新的类中增加一个私有域，它引用现有类的一个实例，这种设计叫做“复合”。这个类也可以被称为包装类 ==[设计模式-装饰者模式]==

**注意：**

包装类不适合用在==回调框架==中，因为被包装类并不知道外部的包装类，所以在回调的时候只会回调本身，不会回调外部的包装类，那么外部包装类就起不到作用。这就是**SELF问题**

**只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的**
</font>