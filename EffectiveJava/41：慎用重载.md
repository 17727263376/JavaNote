<font size = "3">

- **要调用哪个方法进行重载，在编译时就已经做出决定了**

# 重载和覆盖的区别

首先第一点就是覆盖是动态的，他是在运行时选择使用哪一个方法。

而重载在编译时就确定了调用哪个方法

# 避免胡乱的使用方法重载
- 永远不要导出两个具有相同参数数目的重载方法。尽量使重载方法的参数数量不同；对于使用的可变参数，最好不要重载。
- 如果一定要重载，那么对于一对重载方法，至少要有一个对应的参数在两个重载方法中的类型“完全不同”。这样一来，就不可以把一种实例转换为另一种实例，相对来说是保守安全的。
```
public class SetList {
	public static void main(String[] args) {
		Set<Integer> set = new TreeSet<Integer>();
		List<Integer> list = new ArrayList<Integer>();
 
		for (int i = -3; i < 3; i++) {
			set.add(i);
			list.add(i);
		}
 
		for (int i = 0; i < 3; i++) {
			set.remove(i);
			list.remove(i);
		}
 
		System.out.println(set + " " + list);
		//[-3, -2, -1] [-2, 0, 2]结果
	}
}
```
至于为什么会产生这样的结果，原因就是方法重载。

首先set的remove只有一个重载方法，参数为一个类E。在这里由于i是int型变量，所以进行了自动装箱处理变为integer。

然而list的remove却有两个重载方法，其中一个参数为int基本类型，另一个为类E。由于i就是int类型，所以不必装箱，直接就可以调用这个重载方法。因为这两个方法是不同的功能的，所以出现了这样的结果。
# 总结
实际情况往往比上面分析的复杂的多，确定选择哪个重载方法的规则也极其困难。有时候，新增的API可能会违背上面的规则，但是，只要重载的方法执行相同的功能，返回相同的结果，这样也是可以接受的。确保这种行为的标准做法是，**让更具体化的重载方法把调用转发给更一般的重载方法去做**。

总之，能够重载并不意味者应该重载，**一般来说，对于多个具有相同参数数目的重载方法，还是尽量避免使用重载。另外一些情况下，重载方法尽量把调用转发给一般的重载方法去做，不同的重载方法尽量保证行为一致**。
</font>