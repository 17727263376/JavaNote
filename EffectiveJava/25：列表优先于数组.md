[toc]

<font size = "3">

# 数组和列表的不同
- 协变与不可变类型：
> 数组：是协变类型的。协变的意思就是Number是Integer的父类，那么Number[] 
data = new Integer[]; 是成立的。
> 
> 列表：是不可变类型。就是说无法List<Number> list = new List<Integer>();
- 运行时检验与编译器检验:
>数组：运行时检验。因为数组在编译使其创建的类是具体化的。然后在运行期间检验类型约束是否正确。所以就会产生将String类添加到Long类型的数组中会在运行时报java.lang.ArrayStoreException的错误。
>
>泛型：编译期检验。因为泛型会在运行的过程中参数类型会被擦除，所以必须在编译期就得保证类型安全。这就不容许有协变这个性质。

# 数组与泛型无法结合使用
因为数组是在运行期检验的，但是运行期间泛型会被擦除，从而导致Java虚拟机无法判断类型的安全性。

同时由于数组是运行期检验，所以具有协变的特性。这也导致了泛型无法与数组结合。
- 使用泛型的数组(T[] a)和利用泛型转型((T) a)是类型不安全的
- 对泛型使用可变参数列也是不安全的

**所以说，尽量使用列表。但是如果必须使用数组来提高效率的话，只有加上注解这一个方法。**
# 泛型的擦除是什么
泛型使得数据的类别可以像参数一样由外部传递进来。

泛型是 Java 1.5 版本才引进的概念，在这之前是没有泛型的概念的，但显然，泛型代码能够很好地和之前版本的代码很好地兼容。

这是因为，泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型擦除。

通俗地讲，泛型类和普通类在 java 虚拟机内是没有什么特别的地方。

> 在JVM中泛型和普通的类是没有区别的，也就是说任何泛型当它编译成功以后，他都和原生态的类一样。但是为什么要在代码中编写指定的泛型，**泛型可以说是为在编译时做出检查**，当定义泛型以后，一旦出现参数不对，就会在编译时报错。
</font>