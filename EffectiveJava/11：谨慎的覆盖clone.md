[toc]

<font size = "3">

# Cloneable接口
一个类要想实现克隆，需要**实现Cloneable接口**，表明这个类的对象具有克隆的功能。

Cloneable接口是一个mixin接口，它里面并没有任何的抽象方法，类似的接口有Serializable接口，表明该类的对象可以序列化。

# 克隆是什么意思
通过一个对象克隆出另一个对象，简称对象1和对象2，这两个对象就成为两个独立的对象，

那么对对象1做任何的修改，对象2应该不受影响；对对象2做任何的修改的，对象1就不应该受影响。这样就要求对象1与对象2的实例域各自是独立的。

那么我们知道一个对象的实例域，包括基本类型（int，long..等等）的域，引用类型的域（分为可变的域和final不可变的域）。

# clone的通用约束
- x.clone() != x        **应该返回true**
- x.clone().getClass() == x.getClass()        **应该返回true**
- x.clone().equals(x)          **应该返回true**

# 实现clone中容易出现的错误
- **对于实现了Cloneable的类，我们总是希望他也能提供一个公有的clone方法。**

如果我们在一个类的clone()方法只调用super.clone()，然后返回，它**仅仅是返回了一个新的对象**，这个对象具有和原对象**一样的基本类型域**，

但是这个对象的**引用类型域引用的对象还是原对象的引用类型域所引用的对象**。这样就导致一个问题，对原对象引用类型的域所做的修改会影响到新对象的引用类型域。     

也就是说调用Object类的克隆方法，仅仅完成了新对象的创建，和基本类型域的克隆，但是引用类型域的引用还是指向了旧对象的引用类型域的实例

> 对于引用类型域只有final不可变类型的类，可以直接调用super.clone因为他们是不可变的，所以可以直接用

- **clone方法中不应该调用本类或者父类的其他方法**

# 解决方法
使用super.clone()必须保证它的所有父类都具有**非常优美无误的clone函数**，这样才能直接调用，一旦出现一点错误都将带来非常的后果。

- 对于super.clone得到的类，将所有域都设置成空白，在重新赋值，这样的办法虽然简单、合理。但是运行起来不够快
- 设置构造克隆函数或者克隆工厂
```
public Yum(Yum m){};//克隆构造函数
public static Yum newInstance(Yum m)//克隆静态工厂
```
- 对于仅仅用来继承的类，他的clone函数应该尽可能的模仿Object的clone方法，即：**声明为protected、抛出CloneNotSupportedException异常，并且不应该实现Cloneable接口，这样可以使子类具有实现和不实现这个接口的自由。**

# 建议
对于设置构造克隆函数或者克隆工厂它比实现Cloneable接口**有太多优势**，

所以有些专家级的程序员干脆**从来不去覆盖clone方法**，也从来**不会调用它**，除非拷贝数组。对于一个专门为了继承而设计的类，如果你不能提供一个行为良好的受保护的clone方法，它的子类就不应该去实现Cloneable接口也不可能实现。
</font>