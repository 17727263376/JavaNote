[toc]

<font size = "3">

# 基本概念
## 什么是终结方法
JAVA中的终结方法就是 **finalize();** 他和C++中的**析构函数**是一样的功能，即当JVM执行垃圾回收机制时会调用，但是这样的调用**不是百分百**会调用的，它的主要缺点就是：
- 不能保证能够及时的调用
- 根本不会被执行

通过System.gc()方法**仅仅是通知JVM执行垃圾回收**，但是具体什么时候回收、回收不回收还是由JVM来决定。

## finalize的执行过程
当对象不可达时（**也就是失效后**），GC会判断该对象是否覆盖了finalize方法，如**没有覆盖则直接将其回收**，否则，若对象未执行过finalize方法，将其**放入F-Queue队列**，由一**低优先级线程**执行该队列中对象的finalize方法。执行finalize方法完后，GC会**再次判断**该对象是否可达，若不可达则进行回收。否则对象 **“复活”** 。

## finalize会消耗系统性能


# 不调用终结方法的解决方案

**提供显示的释放资源的方法**

值得一提的一个细节就是在类内部中应该有一个私有成员变量**记录该类是否被终结**，避免多次执行终结方法。显示的终止方法通常与try-finally结构结合起来，这样==即使对象使用时有异常抛出，也能及时的调用到显示的终结方法==

# 何时可以使用终结方法
1. 在用户忘记调用显示的终结方法时起到双重保护作用
2. ==与对象的本地对等体有关(?不懂)==

# 终结方法守卫者
在一条继承链中，如果子类需要被销毁，则父类也要调用终结方法被销毁。所以**为了避免用户忘记调用父类的终结方法**，就可以使用终结方法守护者模式

在类增加一个**私有唯一实例的守卫者匿名内部类**，并在这个匿名类中实现外部类的终结方法。这样在子类继承他的时候就不用管父类是否有终结方法，因为super.finalize()并不起作用

```
public class Foo
{
    //创建一个唯一的私有匿名内部类
    private final Object finalizerGuardian =new Object()
    {
        @override
        protected void finalize()throws Throwable
        {
            //在这里实现外部类的终结
        }
    };
```
当外部类是不可达时，这个终结方法守卫者也是不可达的了，垃圾回收器回收外部类的同时也会回收终结方法守卫者的实例，而终结方法守卫者的finalize方法就把外部类的资源释放掉
</font>